import numpy as np
import matplotlib.pyplot as plt
import logging
logging.basicConfig( level=logging.WARNING )


class OutlierGenerator:
    def __init__(self, mean, standard_deviation, number_of_outliers, sample_size):
        """
        Initialize Outlier Generator
        :param mean: mean value of Gaussian distribution 
        :param standard_deviation: standard deviation of Gaussian distribution
        :param number_of_outliers: Number of outlier to be generated for sample size equals to sample_size
        :param sample_size: sample size with in which outliers are distributed
        """

        # verify the parameters
        if standard_deviation < 0:
            logging.critical( "Standard deviation cannot be negative" )
            exit()

        if number_of_outliers > sample_size:
            logging.critical( "Distribution sample size cannot be less than number of outliers" )
            exit()

        # Initialize
        self.mean = mean
        self.standard_deviation = standard_deviation
        self.number_of_outliers = number_of_outliers
        self.outlier_distribution_sample_size = sample_size
        self.sample_counter = 0
        self.outlier_position = []
        self.generate_outlier_position()

    def generate_outlier_position(self):
        """
        Generate position where outlier need to be generated in a given sample size
        :return: NA
        """
        # generate outlier positions
        # for i in range( 0, self.number_of_outliers ):
        #     new_val = np.random.randint( 0, self.outlier_distribution_sample_size )
        #     while new_val in self.outlier_position:
        #         new_val = np.random.randint( 0, self.outlier_distribution_sample_size )
        #     self.outlier_position.append( new_val )
        self.outlier_position = np.random.choice(range(0, self.outlier_distribution_sample_size),
                                                 self.number_of_outliers)

        # sort outlier position in increasing order, fastens the generate
        self.outlier_position.sort()

    def generate(self, repeat=True):
        """
        Generate outliers at positions generated by "generate_outlier_position" function
        :param repeat: repeats outlier position generation every time sample size is exhausted, default value is True
        :return: outlier value (dtype = float)
        """

        # check if outlier position matches the location counter
        if self.sample_counter in self.outlier_position:
            # generate random value with specified mean and standard deviation
            ret_val = np.random.normal( loc=self.mean, scale=self.standard_deviation )
        else:
            ret_val = 0

        # increment location counter, so to keep track
        self.sample_counter = self.sample_counter + 1

        # generate new outliers if sample counter is greater or equal to distribution sample size
        if repeat:
            if self.sample_counter >= self.outlier_distribution_sample_size:
                self.generate_outlier_position()
                self.sample_counter = 0

        return float(ret_val)


# ----------------------------------------- Test cases -------------------------------------------------

if __name__ == '__main__':
    print( "OutlierGenerator test" )
    n = 1000
    outlier_model = OutlierGenerator( mean=0, standard_deviation=0.3, number_of_outliers=10, sample_size=100 )
    x = np.zeros( n )
    y = np.zeros( n )
    for i in range( 1, n ):
        x[i] = outlier_model.generate()
        y[i] = i
    plt.title( "Outlier ($n = " + str( n ) + "$ steps)" )
    plt.plot( y, x )
    plt.show()
